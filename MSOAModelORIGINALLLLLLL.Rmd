---
title: "MSOA affordability model"
author: "Jonathan Bourne"
date: "30 July 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---


I realised that If I am not using vacants which has no statistical significance, Then I can change my model and use MSOA. This is becuase deprivation is at LSOA level and area income statistics are at MSOA level and price works down to ward level.

In fact even ward level might be ok if we use MSOA level income stats.

```{r}


test <- DistribCompareBootstrapper(ChelseaLONDATA, 1652, 100, type=NULL, PropertyTypes)


test2 <- DistribCompareBootstrapper2(ChelseaLONDATA, 1652, 100, type=NULL, PropertyTypes, GroupVars = "MSOA11CD")

test3 <- test2 %>%
         group_by(ID, Admin_ward_code) %>%
         summarise(Homes = sum(Homes),
                   HomesValue = sum(HomesValue),
                   LowUse = sum(LowUse),
                   LowUseValue = sum(LowUseValue),
                   HighVal = sum(HighVal)) %>%
         mutate(HomesPrice = HomesValue/Homes,
                LowUsePrice = LowUseValue/LowUse)

# %>%
#   group_by(Admin_ward_code, ID) %>%
#   summarise(Homes = sum(Homes),
#             LowUse = sum(LowUse),
#             HighVal = sum(HighVal)) %>%
#   mutate(ratio = HighVal/LowUse)

test4 <- test3 %>%
  group_by(Admin_ward_code) %>%
  summarise_all(mean, rm.na = T)


test5 <- test2 %>%
  filter(Admin_ward_code == "E05009394")

```



```{r}
setwd("/home/jonno/Dropbox/SSE/Empty Homes/BootStrapAuthorities2")
  
#Find what needs to be bootstrapped
BootStrapFiles <- list.files(getwd()) %>% gsub("DATA.rds", "",.)
  newLADsnames <- sub("DATA", "", ls(pattern = "DATA", envir = globalenv())) %>% 
    .[!(. %in% BootStrapFiles)] 
  newLADs <- paste0(newLADsnames, "DATA") 

  
   #only bootstrap if there is something to add.
  #Save each boostrap as you go along to avoid losing it all in a crash
  if(length(newLADsnames)>0){
    newLADs  %>% walk(~{print(.x)
      DistribCompareBootstrapper2(get(.x), 1652, 1000, type=NULL, PropertyTypes, GroupVars = "MSOA11CD")%>%
      saveRDS(., file = paste0(.x, ".rds"))
      }) 
  }

  
    #once all Bootratps complete load them all into a list
 BootStrapRES <- list.files(getwd()) %>%
   map(~readRDS(.x))
 
 #name the list
 names(BootStrapRES) <- list.files(getwd()) %>% gsub(".rds", "",.)
  
```


To get the modelling variables

HighVal, Mean property Price, Deprivation

```{r}

#Get MSOA deprivation
MSOAdep <- LSOADep %>%
  select(LSOA_CODE, Rank = Rank..where.1.is.most.deprived., Decile = Decile..where.1.is.most.deprived.10..of.LSOAs.) %>%
  left_join(select(EW2, ECODE, MSOA11CD), by= c("LSOA_CODE"= "ECODE")) %>%
  select(-LSOA_CODE) %>%
  group_by(MSOA11CD) %>%
  summarise_all(mean)

BootDeets <- BootStrapRES %>%
  map_df(~ .x %>% 
  mutate(Reference = HighVal>(LowUse-HighVal),
         Reference2 = MedianHomes<MedianLUPs,
         AllProps = Homes+LowUse,
         prices = (HomesValue+LowUseValue)/AllProps,  #this creates the average price for the MSOA as if mean price had been bootstrapped
         LowUsePerc = LowUse/AllProps) %>%
  select(Reference, Reference2, MSOA11CD, prices, ID, LowUsePerc) ) %>%
   left_join(IncomeEst %>%
              select( MSOA11CD, Yearly.income), by = "MSOA11CD") %>%
  mutate(Affordratio = prices/Yearly.income,
         Affordratio2 = Affordratio^2,
         Affordratio3 = Affordratio^3)%>%
  left_join(MSOAdep)


```



```{r}


MeanOut <- BootDeets %>%
  group_by(MSOA11CD) %>%
  summarise(Mean = mean(Reference),
            Reference = Mean>0.5)

#Mean percentage of MSOA that are investment is about 50% on partial bootstrap
test <-BootDeets %>%
  group_by(ID) %>%
  summarise(Total = sum(Reference)/n())
test %>% ggplot(aes(x = Total)) + geom_density()


#create sample
set.seed(1983)
TestResample <- 1:50 %>% map(~  resample_partition(MeanOut, c(test = 0.1, train = 0.9)))

#set formula
OpenFormula <- as.formula(Reference~Affordratio + Decile)  

BootMod <- MakeBootModels(BootDeets, as.integer(TestResample[[1]]$train), ModForm = OpenFormula)
Predsdf <- MakeBootPreds(BootDeets, BootMod, as.integer(TestResample[[1]]$test))
Accdf   <- MakeBootAccuracy(Predsdf, BootDeets, as.integer(TestResample[[1]]$test)) 

#Beats Null 100% of the time
sum(Accdf$Accuracy>Accdf$AccuracyNull)

median(Accdf$Accuracy-Accdf$AccuracyNull)

#Average accuracy
mean(Accdf$Accuracy)

set.seed(4622)
Modeldf <- BootDeets  %>%
  vfold_cv(., V = 5, repeats = 5) %>%
  mutate(LogisticOpen = splits %>%
  map(.,~{ glm(OpenFormula, data = analysis(.x),binomial(link='logit'))}
        ),
  ForestOpen = splits %>% 
    map(., ~{rpart(OpenFormula, data=analysis(.x))})
  ) %>%
  mutate(LogOpenAcc = GetAccuracy(., "splits", "LogisticOpen"),
         ForestOpenAcc = GetAccuracyForest(., "splits", "ForestOpen"))

```



```{r}
CoeffsMega <- 1 %>%
  map_df(~{
    print(.x)
    BootMod <- MakeBootModels(BootDeets, as.integer(TestResample[[.x]]$train), ModForm =  OpenFormula )

    #needs to be mapped again to extract every model not just the first 50!
Out <- 1:length(BootMod) %>% map_df( ~BootMod[[.x]] %>% tidy %>% mutate(ID = .x)
  )

Out  %>%
  mutate(Sample = .x) 
  })


CoeffsMega %>%
  filter(term !="(Intercept)") %>%
  ggplot(aes(x = term, y = estimate, fill = term)) + geom_boxplot()
```


#Terrible Regression
```{r}

BootModReg <- MakeBootModelsReg(BootDeets, as.integer(TestResample[[1]]$train), 
                                ModForm = as.formula(LowUsePerc~Affordratio + Affordratio2+ Affordratio3+ Decile))
PredsdfReg <- MakeBootPredsReg(BootDeets, BootModReg, as.integer(TestResample[[1]]$test))
AccdfReg   <- MakeBootAccuracyReg(PredsdfReg, BootDeets, as.integer(TestResample[[1]]$test)) 

MakeBootModelsReg <- function(df, trainvect, ModForm = OpenFormula){
  
  BootMod <- (1:max(df$ID)) %>%
  map(~{
    
    ModData <- df %>%
      filter(ID ==.x)

  model <- lm(ModForm,
               data = ModData[trainvect,])
      
  }
    
  )
  
}


MakeBootPredsReg <- function(df, BootMod, testvect){
  
  Predsdf <- 1:length(BootMod) %>%
  map(~{
    
        ModData <- df %>%
      filter(ID ==.x)
    
    
    tibble(v1 =predict(BootMod[[.x]], ModData[testvect,])) 
  }) %>%
  bind_cols() %>% set_names(make.names(1:length(BootMod)))
  
  return(Predsdf)
  
}

MakeBootAccuracyReg <- function(Predsdf, df, testvect){
  
    Accdf <- 1:ncol(Predsdf) %>%
  map_df(~{
    
    ModData <- df %>%
      filter(ID ==.x)
    

    Confmat <- postResample( Predsdf[,.x] %>% unlist,
                              ModData$LowUsePerc[testvect])

  Out<- bind_cols(Confmat %>% as.matrix %>%t %>% data.frame) %>%
  mutate(ID = .x) %>% as.tibble
  
  })
  
}

```

